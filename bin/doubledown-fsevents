#!/usr/bin/ruby

require 'optparse'
require 'osx/foundation'

OSX.require_framework "/System/Library/Frameworks/CoreServices.framework#{
  }/Frameworks/CarbonCore.framework"
include OSX

class Doubledown

  def initialize(local, remote, options)
    @options = options

    # Decide on the local path.
    Dir.mkdir(local) unless File.directory?(local)
    @local = File.expand_path(local)

    # Parse the server and remote path.  Decide on the remote username.
    raise unless remote =~ /^(?:([^@]+)@)?([^:]+):(.+)$/
    @user, @server, @remote = $1, $2, $3
    @user ||= ENV["USER"]

  end

  def run
    $stderr.puts "# [doubledown-fsevents] syncing #{@local
      } changes to #{@server}:#{@remote}"
    recache

    fsevents_cb = proc do |stream, context, count, paths, flags, events|
      paths.regard_as("*")
      count.times do |i|
        dirname = paths[i].gsub(%r</$>, "")
        deleted_files dirname
        modified_files dirname
      end
      recache
    
      # Keep the process tree clean.
      begin
        while pid = Process.wait(-1); end
      rescue; end
    end
    
    # Begin incremental syncing from local to remote.
    stream = FSEventStreamCreate(
      KCFAllocatorDefault,
      fsevents_cb,
      nil,
      [@local],
      KFSEventStreamEventIdSinceNow,
      0.1,
      0
    ) 

    die "Failed to create the FSEventStream" unless stream

    FSEventStreamScheduleWithRunLoop(
      stream,
      CFRunLoopGetCurrent(),
      KCFRunLoopDefaultMode)

    ok = FSEventStreamStart(stream)
    die "Failed to start the FSEventStream" unless ok

    # This call never returns except by an exception.
    begin
      CFRunLoopRun()
    rescue Interrupt
      FSEventStreamStop(stream)
      FSEventStreamInvalidate(stream)
      FSEventStreamRelease(stream)
    end
  end

private

  def deleted_file(pathname)
    pathname2 = "#{@remote}#{pathname.sub(@local, "")}"
    ssh("rm -d #{pathname2.inspect} 2>/dev/null", "removed #{pathname2}")
  rescue => e
    $stderr.puts e.inspect
    $stderr.puts e.backtrace
    raise e
  end

  def deleted_files(dirname)
    ((@cache[dirname] || {}).keys - Dir.entries(dirname)).each do |basename|
      deleted_file File.join(dirname, basename)
    end
  end

  # Run a command in the background.  This actually forks twice, leaving the
  # intermediate process an opportunity to print a message.
  def fork_exec(argv, message)
    fork do
      if system(*argv)
        $stderr.puts "# [doubledown-fsevents] #{message}"
      end
    end
  end

  def modified_file(pathname)
    pathname2 = "#{@remote}#{pathname.sub(@local, "")}"
    #$stderr.puts "# [doubledown-fsevents] uploading #{pathname2}"
    fork_exec(["rsync", "-aiz"] + @options + [
      pathname,
      "#{@user}@#{@server}:#{pathname2}"
    ], "uploaded #{pathname2} (excluded files were not uploaded)")
  rescue => e
    $stderr.puts e.inspect
    $stderr.puts e.backtrace
    raise e
  end

  def modified_files(dirname)
    Dir.foreach dirname do |basename|
      next if "." == basename || ".." == basename
      pathname = File.join(dirname, basename)
      if cached_stat = (@cache[dirname] || {})[basename]
        stat = File.lstat(pathname)
        if cached_stat.mtime != stat.mtime || cached_stat.size != stat.size
          modified_file pathname
        end
      else
        modified_file pathname
      end
    end
  end

  # Keep a cache of `File::Stat` objects because the FSEvents API is not
  # as awesome as `inotify`(7) on Linux.
  def recache(dirname=@local)
    @cache ||= {}
    @cache[dirname] = {}
    Dir.foreach dirname do |basename|
      pathname = File.join(dirname, basename)
      stat = File.lstat(pathname)
      @cache[dirname][basename] = stat
      if stat.symlink?
      elsif stat.directory? && "." != basename && ".." != basename
        recache pathname
      end
    end
  end

  # Run a command remotely via SSH.  Avoid single quotes in the command.
  def ssh(command, message)
    fork_exec([
      "ssh",
      "#{@user}@#{@server}",
      "/bin/sh -c '#{command}'",
    ], message)
  end
end

options = [] 

OptionParser.new do |parser|
  parser.banner = "Usage: <local> [<user>@]<server>:<remote>"
  parser.on_tail("-h", "--help", "show this help message") do
    puts parser
    exit
  end
  parser.on("-p", "--pretend", "list files, don't copy") { 
    options << "--list-only" }
end.parse!

# find excludes file
options << "--exclude=.excludes*"
if File::exists?("#{ARGV[0]}/.excludes")
  options << "--exclude-from=#{ARGV[0]}/.excludes"
end

trap("EXIT") { Process.waitall }

Doubledown.new(ARGV[0], ARGV[1], options).run
