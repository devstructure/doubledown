#!/bin/sh
set -e

usage() {
	echo "Usage: $(basename $0) <local> [<user>@]<server>:<remote>" >&2
	[ -n "$1" ] && {
		echo "  <local>   local pathname to sync" >&2
		echo "  <user>    user that will connect to <remote>" >&2
		echo "  <server>  remote server" >&2
		echo "  <remote>  pathname to push to on <remote>" >&2
		echo "  -p        don't copy files" >&2
		echo "  -h|--help show this help message" >&2
		exit 0
	} || exit 1
}

[ "--help" = "$1" ] && usage help
while getopts h:p NAME
do
	case "$NAME" in
		h) usage help;;
		p) PRETEND="--dry-run";;
		*) usage;;
	esac
done

env growlnotify -h > /dev/null 2> /dev/null
has_growl=$?

LOCAL=$(readlink -f "$1")
[ "$2" != "${2%%@*}" ] && USER="${2%%@*}"
SERVER="${2##*@}"; SERVER="${SERVER%%:*}"
REMOTE="${2##*:}"
[ -z "$LOCAL" ] && usage
[ -z "$USER" ] && usage
[ -z "$SERVER" ] && usage
[ -z "$REMOTE" ] && usage

EXCLUDES="--exclude=.excludes*"
if [ -e "$LOCAL/.excludes" ]
then
    EXCLUDES="--exclude=.excludes* --exclude-from=$LOCAL/.excludes"
fi

# FIXME This does not work.  `doubledown-inotify` should wait on all its
# children before succumbing to `SIGINT`.  In practice, it's not a huge
# deal because the children run to completion.
trap wait 0 2

# Let `inotifywait`(1) gather all write events in the directory of interest
# and pass them to a child process for syncing.  The child process goes
# into the background so the `inotifywait` output reader can get back to
# business.  The shell will `wait`(2) with `WNOHANG` after every command to
# prevent piles of zombie processes from building up.
if [ "$has_growl" == "0" ] ; then
    growlnotify "# [doubledown-fsevents] syncing $LOCAL changes to $SERVER:$REMOTE" >&2
else
	echo "# [doubledown-fsevents] syncing $LOCAL changes to $SERVER:$REMOTE" >&2
fi

inotifywait -mrq \
	-e modify,attrib,move,move_self,create,delete \
	--format "%e %w%f" "$LOCAL" | while read LINE
do
	(
		EVENT="$(echo "$LINE" | cut -d" " -f1)"
		PATHNAME="$(echo "$LINE" | cut -d" " -f2-)"
		PATHNAME2="${PATHNAME##$LOCAL/}"
		case "$EVENT" in
			delete|moved_from)
				ssh "$USER@$SERVER" rm -d "$PATHNAME2" 2>/dev/null
				if [ "$has_growl" == "0" ] ; then
				    growlnotify "# [doubledown-inotify] removed $PATHNAME2" >&2;;
				else
					echo "# [doubledown-inotify] removed $PATHNAME2" >&2;;
				fi
			*)
				#echo "# [doubledown-inotify] uploading $PATHNAME2" >&2
				rsync $EXCLUDES $PRETEND -aiz "$PATHNAME" "$USER@$SERVER:$REMOTE/$PATHNAME2" 2>/dev/null
				if [ "$has_growl" == "0" ] ; then
				    growlnotify echo "# [doubledown-inotify] uploaded $PATHNAME2" >&2;;
				else
					echo "# [doubledown-inotify] uploaded $PATHNAME2" >&2;;
				fi
		esac
	) &
done
